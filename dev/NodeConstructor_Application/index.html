<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Nodeconstructor - Application · ElectricGrid.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="ElectricGrid.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ElectricGrid.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Welcome</a></li><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li><span class="tocitem">Environment</span><ul><li><a class="tocitem" href="../Env_Create/">Configuring the Environment</a></li><li><a class="tocitem" href="../Env_Interaction/">Interaction with the Environment</a></li></ul></li><li><span class="tocitem">Classical Controllers</span><ul><li><a class="tocitem" href="../Classical_Controllers_Swing/">Swing Mode</a></li><li><a class="tocitem" href="../Classical_Controllers_PQ/">PQ Mode</a></li><li><a class="tocitem" href="../Classical_Controllers_Droop/">Droop Controllers</a></li><li><a class="tocitem" href="../Classical_Controllers_VSG/">Virtual Synchronous Generator</a></li><li><a class="tocitem" href="../Auxiliaries_OU_process/">Auxiliaries</a></li></ul></li><li><span class="tocitem">Reinforcement Learning</span><ul><li><a class="tocitem" href="../RL_Single_Agent/">Reinforcement Learning using ElectricGrid</a></li><li><a class="tocitem" href="../RL_Classical_Controllers_Merge/">Multicontroller</a></li><li><a class="tocitem" href="../RL_Complex/">Reinforcement Learning in Larger Grids </a></li></ul></li><li><span class="tocitem">Nodeconstructor</span><ul><li><a class="tocitem" href="../NodeConstructor_Theory/">The Nodeconstructor - Theory</a></li><li class="is-active"><a class="tocitem" href>The Nodeconstructor - Application</a><ul class="internal"><li><a class="tocitem" href="#Automatic-Generation-of-Grids"><span>Automatic Generation of Grids</span></a></li><li><a class="tocitem" href="#Three-phase-simulation"><span>Three-phase simulation</span></a></li></ul></li></ul></li><li><span class="tocitem">Miscellanous</span><ul><li><a class="tocitem" href="../Default_Parameters/">Default Parameters</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li><li><a class="tocitem" href="../dev/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Nodeconstructor</a></li><li class="is-active"><a href>The Nodeconstructor - Application</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The Nodeconstructor - Application</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/upb-lea/ElectricGrid.jl/blob/main/docs/src/NodeConstructor_Application.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="NodeConstructor-Application"><a class="docs-heading-anchor" href="#NodeConstructor-Application">NodeConstructor Application</a><a id="NodeConstructor-Application-1"></a><a class="docs-heading-anchor-permalink" href="#NodeConstructor-Application" title="Permalink"></a></h1><p>The creation of a grid always follows a certain pattern and can therefore be automated. In this way, you can avoid errors that may arise from the handwritten rearrangement of the equations. It is therefore obvious to write an automatism for the generation, which generates the matrices on the basis of input parameters. In this notebook we will discuss:</p><ul><li><h3>Automatic Generation of Grids</h3></li><li><h3>Three-phase Systems</h3></li></ul><h2 id="Automatic-Generation-of-Grids"><a class="docs-heading-anchor" href="#Automatic-Generation-of-Grids">Automatic Generation of Grids</a><a id="Automatic-Generation-of-Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Generation-of-Grids" title="Permalink"></a></h2><p>In this part of the notebook the example of the <code>NodeConstructor_Theory.ipynb</code> shall be reproduced with the help of the NodeConstructor.</p><p>An important point is the information about how the components are connected by which cable. To pass this information to the NodeConstructor we introduce the connection matrix (<code>CM</code>).</p><h3 id="Structured-Grid-Generation-via-Connection-Matrix"><a class="docs-heading-anchor" href="#Structured-Grid-Generation-via-Connection-Matrix">Structured Grid Generation via Connection Matrix</a><a id="Structured-Grid-Generation-via-Connection-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Structured-Grid-Generation-via-Connection-Matrix" title="Permalink"></a></h3><p>The connection matrix specifies how the elements of the grid are connected. In our grid there are two basic elements: sources and loads, which are then connected via cables.</p><p>To get a better understanding of the CM, the CM of the previous example is shown below:</p><table><tr><th style="text-align: left">From\To</th><th style="text-align: center">Source 1</th><th style="text-align: center">Source 2</th><th style="text-align: center">Load 1</th></tr><tr><td style="text-align: left"><strong>Source 1</strong></td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">1</td></tr><tr><td style="text-align: left"><strong>Source 2</strong></td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">2</td></tr><tr><td style="text-align: left"><strong>Load 1</strong></td><td style="text-align: center">-1</td><td style="text-align: center">-2</td><td style="text-align: center">0</td></tr></table><p>The first column of the above matrix indicates which element we start from. The sources are considered first and after that the loads. The first row of the matrix indicates the elements to which we can connect. The number and order is identical to the first column.</p><p>Since our grid elements cannot be connected to themselves, there are always zeros on the main diagonal. In the second row of the table we can now identify the connections of the first source. This source is not connected to the second source but to the first load, which is why we find a &quot;1&quot; in this cell. We can read this entry as: &quot;Source 1 is connected to load 1 by cable 1&quot;. In the third row of the table above, all connections are made from source 2, which is connected to load 1 via cable 2. The fourth line contains the connections of the 1 load. As shown before, it is connected to source 1 and source 2, but the entries have a negative sign. The negative sign indicates that the flow direction of the current is assumed to be negative. The sign of the entries is taken into account when constructing the DGLs, but has no influence on the subsequent current flow in the simulation. The matrix is antisymmetric, which means that we have a mirroring of the matrix along the main diagonal with the sign of the entries reversed.</p><p>In Julia, this matrix then looks like this:</p><pre><code class="language-julia hljs">CM = [ 0  0  1
       0  0  2
      -1 -2  0];</code></pre><p>We now import the ElectricGrid package:</p><pre><code class="language-julia hljs"># Import the package
using ElectricGrid</code></pre><div style="padding: 1em; background-color: #f8d6da; border: 1px solid #f5c6cb; font-weight: bold;">
<p>The WebIO Jupyter extension was not detected. See the
<a href="https://juliagizmos.github.io/WebIO.jl/latest/providers/ijulia/" target="_blank">
    WebIO Jupyter integration documentation
</a>
for more information.
</div><p>To reproduce the above example exactly, the important parameters must be passed through the parameter dict: </p><pre><code class="language-julia hljs"># Source
R = 1.1e-3
L = 70e-6
R_c = 7e-3
C = 250e-6

# Cable
C_b = 1e-4/2
L_b = 1e-4
R_b = 1e-3

# Load
R_l = 100
C_l = 1e-2
L_l = 1e-2;</code></pre><pre><code class="language-julia hljs">parameters = Dict()

grid_properties = Dict()
grid_properties[&quot;fs&quot;] =  10e3
grid_properties[&quot;v_rms&quot;] = 230
grid_properties[&quot;phase&quot;] = 1;
parameters[&quot;grid&quot;] = grid_properties

source1 = Dict()
source2 = Dict()
source_list = []

source1[&quot;fltr&quot;] = &quot;LCL&quot;
source1[&quot;R1&quot;] = R
source1[&quot;L1&quot;] = L
source1[&quot;C&quot;] = C
source1[&quot;R_C&quot;] = R_c
source1[&quot;R2&quot;] = R
source1[&quot;L2&quot;] = L

source2[&quot;fltr&quot;] = &quot;LC&quot;
source2[&quot;R1&quot;] = R
source2[&quot;L1&quot;] = L
source2[&quot;C&quot;] = C
source2[&quot;R_C&quot;] = R_c
push!(source_list, source1, source2)

parameters[&quot;source&quot;] = source_list

cable = Dict()
cable[&quot;R&quot;] = R_b
cable[&quot;L&quot;] = L_b
cable[&quot;C&quot;] = C_b
cable_list = []

push!(cable_list, cable, cable);
parameters[&quot;cable&quot;] = cable_list

load1 = Dict()
load_list = []

load1[&quot;impedance&quot;] = &quot;RLC&quot;
load1[&quot;R&quot;] = R_l;
load1[&quot;L&quot;] = L_l;
load1[&quot;C&quot;] = C_l;

push!(load_list, load1);
parameters[&quot;load&quot;] = load_list;</code></pre><p>Now the NodeConstructor is called. In addition to the number of sources and loads, this also receives the CM and the parameter dict:</p><pre><code class="language-julia hljs">S2_L1 = NodeConstructor(num_sources=2, num_loads=1, parameters=parameters, CM=CM);</code></pre><p>With the function <code>DrawGraph()</code> the topology of the grid can now be displayed. Here, the color orange corresponds to a source and the color blue corresponds to a load.</p><pre><code class="language-julia hljs">DrawGraph(S2_L1)</code></pre><html>
<head><meta charset="utf-8" /></head>
<body>
<div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_SVG"></script>
    <script type="text/javascript">
window.PlotlyConfig = {MathJaxConfig: 'local'};
</script>
<script type="text/javascript">
if (window.MathJax) {MathJax.Hub.Config({SVG: {font: "STIX-Web"}});}
</script>
<script type="text/javascript">
    if (typeof require !== 'undefined') {
        require.undef("plotly");
        requirejs.config({
            paths: {
                'plotly': ['https://cdn.plot.ly/plotly-2.3.0.min']
            }
        });
        require(['plotly'], function(Plotly) {
            window._Plotly = Plotly;
        });
    }
</script>

    <div
        id=98fa629d-3d68-41da-a6b8-33bde237e67a
        class="plotly-graph-div"
        style="height:100%; width:100%;">
    </div>
    <script type="text/javascript">
        require(["plotly"], function(Plotly) {
        window.PLOTLYENV = window.PLOTLYENV || {}

        if (document.getElementById('98fa629d-3d68-41da-a6b8-33bde237e67a')) {
    Plotly.newPlot(
        '98fa629d-3d68-41da-a6b8-33bde237e67a',
        [{"mode":"lines","line":{"color":"#113","width":0.8},"y":[0.0,-0.8660254037844385,null,0.8660254037844387,-0.8660254037844385,null],"type":"scatter","x":[1.0,-0.5000000000000004,null,-0.4999999999999998,-0.5000000000000004,null]},{"x":[1.0,-0.4999999999999998,-0.5000000000000004],"mode":"markers","y":[0.0,0.8660254037844387,-0.8660254037844385],"type":"scatter","text":["Source: LCL","Source: LC","Load: RLC"],"marker":{"color":["#FF8800","#FF6600","#8F00D1"],"line":{"color":"Black","width":1},"size":13}}],
        {"showlegend":false,"xaxis":{"showgrid":false,"showticklabels":false,"zeroline":false},"hovermode":"closest","template":{"layout":{"coloraxis":{"colorbar":{"ticks":"","outlinewidth":0}},"xaxis":{"gridcolor":"white","zerolinewidth":2,"title":{"standoff":15},"ticks":"","zerolinecolor":"white","automargin":true,"linecolor":"white"},"hovermode":"closest","paper_bgcolor":"white","geo":{"showlakes":true,"showland":true,"landcolor":"#E5ECF6","bgcolor":"white","subunitcolor":"white","lakecolor":"white"},"colorscale":{"sequential":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]],"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]],"sequentialminus":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]},"yaxis":{"gridcolor":"white","zerolinewidth":2,"title":{"standoff":15},"ticks":"","zerolinecolor":"white","automargin":true,"linecolor":"white"},"shapedefaults":{"line":{"color":"#2a3f5f"}},"hoverlabel":{"align":"left"},"mapbox":{"style":"light"},"polar":{"angularaxis":{"gridcolor":"white","ticks":"","linecolor":"white"},"bgcolor":"#E5ECF6","radialaxis":{"gridcolor":"white","ticks":"","linecolor":"white"}},"autotypenumbers":"strict","font":{"color":"#2a3f5f"},"ternary":{"baxis":{"gridcolor":"white","ticks":"","linecolor":"white"},"bgcolor":"#E5ECF6","caxis":{"gridcolor":"white","ticks":"","linecolor":"white"},"aaxis":{"gridcolor":"white","ticks":"","linecolor":"white"}},"annotationdefaults":{"arrowhead":0,"arrowwidth":1,"arrowcolor":"#2a3f5f"},"plot_bgcolor":"#E5ECF6","title":{"x":0.05},"scene":{"xaxis":{"gridcolor":"white","gridwidth":2,"backgroundcolor":"#E5ECF6","ticks":"","showbackground":true,"zerolinecolor":"white","linecolor":"white"},"zaxis":{"gridcolor":"white","gridwidth":2,"backgroundcolor":"#E5ECF6","ticks":"","showbackground":true,"zerolinecolor":"white","linecolor":"white"},"yaxis":{"gridcolor":"white","gridwidth":2,"backgroundcolor":"#E5ECF6","ticks":"","showbackground":true,"zerolinecolor":"white","linecolor":"white"}},"colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"]},"data":{"barpolar":[{"type":"barpolar","marker":{"line":{"color":"#E5ECF6","width":0.5}}}],"carpet":[{"aaxis":{"gridcolor":"white","endlinecolor":"#2a3f5f","minorgridcolor":"white","startlinecolor":"#2a3f5f","linecolor":"white"},"type":"carpet","baxis":{"gridcolor":"white","endlinecolor":"#2a3f5f","minorgridcolor":"white","startlinecolor":"#2a3f5f","linecolor":"white"}}],"scatterpolar":[{"type":"scatterpolar","marker":{"colorbar":{"ticks":"","outlinewidth":0}}}],"parcoords":[{"line":{"colorbar":{"ticks":"","outlinewidth":0}},"type":"parcoords"}],"scatter":[{"type":"scatter","marker":{"colorbar":{"ticks":"","outlinewidth":0}}}],"histogram2dcontour":[{"colorbar":{"ticks":"","outlinewidth":0},"type":"histogram2dcontour","colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"contour":[{"colorbar":{"ticks":"","outlinewidth":0},"type":"contour","colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"scattercarpet":[{"type":"scattercarpet","marker":{"colorbar":{"ticks":"","outlinewidth":0}}}],"mesh3d":[{"colorbar":{"ticks":"","outlinewidth":0},"type":"mesh3d"}],"surface":[{"colorbar":{"ticks":"","outlinewidth":0},"type":"surface","colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"scattermapbox":[{"type":"scattermapbox","marker":{"colorbar":{"ticks":"","outlinewidth":0}}}],"scattergeo":[{"type":"scattergeo","marker":{"colorbar":{"ticks":"","outlinewidth":0}}}],"histogram":[{"type":"histogram","marker":{"colorbar":{"ticks":"","outlinewidth":0}}}],"pie":[{"type":"pie","automargin":true}],"choropleth":[{"colorbar":{"ticks":"","outlinewidth":0},"type":"choropleth"}],"heatmapgl":[{"colorbar":{"ticks":"","outlinewidth":0},"type":"heatmapgl","colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"bar":[{"type":"bar","error_y":{"color":"#2a3f5f"},"error_x":{"color":"#2a3f5f"},"marker":{"line":{"color":"#E5ECF6","width":0.5}}}],"heatmap":[{"colorbar":{"ticks":"","outlinewidth":0},"type":"heatmap","colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"contourcarpet":[{"colorbar":{"ticks":"","outlinewidth":0},"type":"contourcarpet"}],"table":[{"type":"table","header":{"line":{"color":"white"},"fill":{"color":"#C8D4E3"}},"cells":{"line":{"color":"white"},"fill":{"color":"#EBF0F8"}}}],"scatter3d":[{"line":{"colorbar":{"ticks":"","outlinewidth":0}},"type":"scatter3d","marker":{"colorbar":{"ticks":"","outlinewidth":0}}}],"scattergl":[{"type":"scattergl","marker":{"colorbar":{"ticks":"","outlinewidth":0}}}],"histogram2d":[{"colorbar":{"ticks":"","outlinewidth":0},"type":"histogram2d","colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"scatterternary":[{"type":"scatterternary","marker":{"colorbar":{"ticks":"","outlinewidth":0}}}],"scatterpolargl":[{"type":"scatterpolargl","marker":{"colorbar":{"ticks":"","outlinewidth":0}}}]}},"showarrow":false,"margin":{"l":50,"b":50,"r":50,"t":60},"plot_bgcolor":"#f1f3f7","yaxis":{"showgrid":false,"showticklabels":false,"zeroline":false},"dragmode":"select"},
        {"editable":false,"responsive":true,"staticPlot":false,"scrollZoom":true},
    )
}

        });
    </script>
</div>

</body>
</html><p>After the grid has been created it can be passed to the function <code>GetSystem()</code>, which then returns the system matrices for the state space representation in the continous time domain.</p><pre><code class="language-julia hljs">A, B, C, D = GetSystem(S2_L1);</code></pre><p>We convert the matrices into the discrete time domain and create a discrete StateSpace object with the help of <code>ControlSystems</code>. This object can then represent the dynamics of the system for a given time interval using the function <code>lsim()</code>.</p><pre><code class="language-julia hljs">ts = 1e-5
Ad = exp(A*ts)
Bd = A \ (Ad - C) * B
sys_d = StateSpace(Ad, Bd, C, D, ts);</code></pre><pre><code class="nohighlight hljs">UndefVarError: StateSpace not defined



Stacktrace:

 [1] top-level scope

   @ In[8]:4</code></pre><p>To use <code>lsim()</code> you need defined initial states <code>x0</code>, a time vector <code>t</code> and a input signal <code>u</code>. In our case we apply a jump to 250 V to the system.</p><pre><code class="language-julia hljs">ns = length(A[1,:]) # get num of states
ni = length(B[1,:]) # get num of inputs
t = collect(0:ts:0.1)
x0 = [0.0 for i = 1:ns]
u = [250.0 for i = 1:length(t)]
uu = [u for i = 1:ni ]
uuu = mapreduce(permutedims, vcat, uu);</code></pre><p><code>lsim()</code> now solves the difference equations for the given time steps and we can observe how the states evolve.</p><pre><code class="language-julia hljs">xout, _, _, _ = lsim(sys_d,uuu,t,x0=x0);</code></pre><pre><code class="nohighlight hljs">UndefVarError: lsim not defined



Stacktrace:

 [1] top-level scope

   @ In[10]:1</code></pre><p>Here we plot the voltage across the capacitor in the first source.</p><pre><code class="language-julia hljs">layout = Layout(xaxis_title=&quot;Time in µs&quot;, yaxis_title=&quot;v_C / V&quot;)
p = plot(t, xout[2,:], layout)</code></pre><pre><code class="nohighlight hljs">UndefVarError: Layout not defined



Stacktrace:

 [1] top-level scope

   @ In[11]:1</code></pre><h3 id="Random-Grid-Generation"><a class="docs-heading-anchor" href="#Random-Grid-Generation">Random Grid Generation</a><a id="Random-Grid-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Random-Grid-Generation" title="Permalink"></a></h3><p>The manual creation of a grid can be time consuming because all parameters have to be specified. To quickly create different topologies with little effort, automatic generation can be used. t only needs the number of sources and loads, all other parameters are set by default or are randomly selected. An important feature is the creation of random node structures, where the parameters of the elements are chosen randomly.</p><pre><code class="language-julia hljs">S2_L2_FC = NodeConstructor(num_sources=2, num_loads=2);</code></pre><pre><code class="nohighlight hljs">******************************************************************************
This program contains Ipopt, a library for large-scale nonlinear optimization.
 Ipopt is released as open source code under the Eclipse Public License (EPL).
         For more information visit https://github.com/coin-or/Ipopt
******************************************************************************</code></pre><p>To create the CM matrix randomly, the parameters <code>S2S_p</code>, <code>L2L_p</code> and <code>S2L_p</code> can also be used to set the connection probabilities. These indicate the probability with which a source/load will be connected to any other source/load. A fully connected grid would be obtained if all parameters are set to 1.</p><pre><code class="language-julia hljs">S2_L2_FC = NodeConstructor(num_sources=2, num_loads=2, S2S_p=1, S2L_p=1, L2L_p=1);</code></pre><p>Let&#39;s check the CM matrix.</p><pre><code class="language-julia hljs">S2_L2_FC.CM</code></pre><pre><code class="nohighlight hljs">4×4 Matrix{Float64}:
  0.0   1.0   2.0  3.0
 -1.0   0.0   4.0  5.0
 -2.0  -4.0   0.0  6.0
 -3.0  -5.0  -6.0  0.0</code></pre><p>With a look into the parameter dict we also see that the parameters of the individual elements were randomly generated. The current policy for the sources is that an LC filter is always taken and the other filter types are chosen randomly.</p><pre><code class="language-julia hljs">S2_L2_FC.parameters[&quot;source&quot;]</code></pre><pre><code class="nohighlight hljs">2-element Vector{Any}:
 Dict{Any, Any}(&quot;L1&quot; =&gt; 683065.1506262049, &quot;C&quot; =&gt; 770.6152043421689, &quot;mode&quot; =&gt; &quot;Synchronverter&quot;, &quot;fltr&quot; =&gt; &quot;LCL&quot;, &quot;pwr&quot; =&gt; 10000.0, &quot;source_type&quot; =&gt; &quot;ideal&quot;, &quot;L2&quot; =&gt; 93413.60873776274, &quot;R_C&quot; =&gt; 9.924097510713226, &quot;std_asy&quot; =&gt; 2500.0, &quot;σ&quot; =&gt; 0.0…)
 Dict{Any, Any}(&quot;L1&quot; =&gt; 455376.76708413655, &quot;C&quot; =&gt; 1155.9228065132534, &quot;mode&quot; =&gt; &quot;Synchronverter&quot;, &quot;fltr&quot; =&gt; &quot;LC&quot;, &quot;pwr&quot; =&gt; 15000.0, &quot;source_type&quot; =&gt; &quot;ideal&quot;, &quot;R_C&quot; =&gt; 6.616065007142151, &quot;std_asy&quot; =&gt; 3750.0, &quot;σ&quot; =&gt; 0.0, &quot;i_limit&quot; =&gt; 52.183509595574726…)</code></pre><p>For larger networks, of course, only the number of sources and loads can be handed over, so that the network structures are created on the basis of the default values. An important point here is that it is ensured that no subnets are created. By default, it is ensured that each element of the network has at least one connection to the other components of the network, so that no subnetworks are created.</p><p>Internally, this is done by checking for connections for each element. If these are not present, they are automatically created. For smaller networks it is advisable to specify a CM matrix, because otherwise usually too many connections are made than necessary. However, this is no longer noticeable with more than 10+ elements.</p><pre><code class="language-julia hljs">S5_L15 = NodeConstructor(num_sources=5, num_loads=15);</code></pre><h2 id="Three-phase-simulation"><a class="docs-heading-anchor" href="#Three-phase-simulation">Three-phase simulation</a><a id="Three-phase-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Three-phase-simulation" title="Permalink"></a></h2><p>Until now, only single-phase grids have been created with NodeConstructor. However, the default value for the number of phases is 3, so we will now also consider the three-phase variant. For the simulation of the grid in 3 phases the system matrix is extended:</p><p class="math-container">\[\begin{equation}
A_{all} = \begin{pmatrix}
        A_{a} &amp; 0 &amp; 0 \\
        0 &amp; A_{b} &amp; 0 \\
        0 &amp; 0 &amp; A_{c} 
    \end{pmatrix}
\end{equation}\]</p><p>Lets see how this looks like in Julia.</p><pre><code class="language-julia hljs">S1_L2 = NodeConstructor(num_sources=1, num_loads=2);</code></pre><pre><code class="language-julia hljs">S1_L2.parameters[&quot;grid&quot;][&quot;phase&quot;]</code></pre><pre><code class="nohighlight hljs">3</code></pre><pre><code class="language-julia hljs">A, B, C, D = GetSystem(S1_L2)
ts = 1e-4
Ad = exp(A*ts)
Bd = A \ (Ad - C) * B
sys_d = StateSpace(Ad, Bd, C, D, ts);</code></pre><pre><code class="nohighlight hljs">UndefVarError: StateSpace not defined



Stacktrace:

 [1] top-level scope

   @ In[19]:5</code></pre><p>We then collect a few useful variables and set the time horizon for the simulation.</p><pre><code class="language-julia hljs">ns = S1_L2.num_spp  # get num of states per phase
ni = S1_L2.num_sources # get num of inputs per phase
t = collect(0:ts:1);</code></pre><p>Next we want to generate the three-phase input signals and repeat it for the number of sources:</p><pre><code class="language-julia hljs"># Stepfunction
u = sqrt(2)*[230, 0, -230]
uu = repeat(u, inner=ni) .* ones(length(t))&#39;;</code></pre><pre><code class="language-julia hljs"># Sin wave
u = [230 * sin.(2*pi*t .- 2/3*pi*(i-1)) for i = 1:3]
uu = transpose(hcat(repeat(u[1], inner=[1,ni]),repeat(u[2], inner=[1,ni]),repeat(u[3], inner=[1,ni])));</code></pre><p>Lets have a look:</p><pre><code class="language-julia hljs">layout = Layout(xaxis_title=&quot;Time in µs&quot;, yaxis_title=&quot;U in V&quot;)
input = 1

phase_a = scatter(x=t, y=uu[input+ni*0,:], mode=&quot;lines&quot;, name=&quot;Phase A&quot;)
phase_b = scatter(x=t, y=uu[input+ni*1,:], mode=&quot;lines&quot;, name=&quot;Phase B&quot;)
phase_c = scatter(x=t, y=uu[input+ni*2,:], mode=&quot;lines&quot;, name=&quot;Phase C&quot;)

plot([phase_a, phase_b, phase_c], layout)</code></pre><pre><code class="nohighlight hljs">UndefVarError: Layout not defined



Stacktrace:

 [1] top-level scope

   @ In[23]:1</code></pre><p>Again, the discretized matrices can now be used to model the grid.</p><pre><code class="language-julia hljs">x0 = [0.0 for i = 1:ns*3]
xout, _, _, _ = lsim(sys_d,uu,t,x0=x0);</code></pre><pre><code class="nohighlight hljs">UndefVarError: lsim not defined



Stacktrace:

 [1] top-level scope

   @ In[24]:2</code></pre><p>Now a state can be selected and the corresponding trajectories can be plotted.</p><pre><code class="language-julia hljs">state_list = GetStateIds(S1_L2)</code></pre><pre><code class="nohighlight hljs">27-element Vector{String}:
 &quot;source1_i_L1_a&quot;
 &quot;source1_v_C_filt_a&quot;
 &quot;source1_i_L2_a&quot;
 &quot;source1_v_C_cables_a&quot;
 &quot;cable1_i_L_a&quot;
 &quot;cable2_i_L_a&quot;
 &quot;load1_v_C_total_a&quot;
 &quot;load1_i_L_a&quot;
 &quot;load2_v_C_total_a&quot;
 &quot;source1_i_L1_b&quot;
 &quot;source1_v_C_filt_b&quot;
 &quot;source1_i_L2_b&quot;
 &quot;source1_v_C_cables_b&quot;
 ⋮
 &quot;load1_v_C_total_b&quot;
 &quot;load1_i_L_b&quot;
 &quot;load2_v_C_total_b&quot;
 &quot;source1_i_L1_c&quot;
 &quot;source1_v_C_filt_c&quot;
 &quot;source1_i_L2_c&quot;
 &quot;source1_v_C_cables_c&quot;
 &quot;cable1_i_L_c&quot;
 &quot;cable2_i_L_c&quot;
 &quot;load1_v_C_total_c&quot;
 &quot;load1_i_L_c&quot;
 &quot;load2_v_C_total_c&quot;</code></pre><pre><code class="language-julia hljs">state = 3
state_list = GetStateIds(S1_L2)

layout = Layout(xaxis_title=&quot;Time in µs&quot;, yaxis_title=&quot;$(state_list[state]) in V&quot;)

phase_a = scatter(x=t, y=xout[state+ns*0,:], mode=&quot;lines&quot;, name=&quot;Phase A&quot;)
phase_b = scatter(x=t, y=xout[state+ns*1,:], mode=&quot;lines&quot;, name=&quot;Phase B&quot;)
phase_c = scatter(x=t, y=xout[state+ns*2,:], mode=&quot;lines&quot;, name=&quot;Phase C&quot;)

plot([phase_a, phase_b, phase_c], layout)
</code></pre><pre><code class="nohighlight hljs">UndefVarError: Layout not defined



Stacktrace:

 [1] top-level scope

   @ In[26]:4</code></pre><h3 id="Access-to-the-different-states"><a class="docs-heading-anchor" href="#Access-to-the-different-states">Access to the different states</a><a id="Access-to-the-different-states-1"></a><a class="docs-heading-anchor-permalink" href="#Access-to-the-different-states" title="Permalink"></a></h3><p>A way to get the different states of our NodeConstructor is to use the function <code>GetStateIds()</code>.</p><pre><code class="language-julia hljs">state_list = GetStateIds(S1_L2)</code></pre><pre><code class="nohighlight hljs">27-element Vector{String}:
 &quot;source1_i_L1_a&quot;
 &quot;source1_v_C_filt_a&quot;
 &quot;source1_i_L2_a&quot;
 &quot;source1_v_C_cables_a&quot;
 &quot;cable1_i_L_a&quot;
 &quot;cable2_i_L_a&quot;
 &quot;load1_v_C_total_a&quot;
 &quot;load1_i_L_a&quot;
 &quot;load2_v_C_total_a&quot;
 &quot;source1_i_L1_b&quot;
 &quot;source1_v_C_filt_b&quot;
 &quot;source1_i_L2_b&quot;
 &quot;source1_v_C_cables_b&quot;
 ⋮
 &quot;load1_v_C_total_b&quot;
 &quot;load1_i_L_b&quot;
 &quot;load2_v_C_total_b&quot;
 &quot;source1_i_L1_c&quot;
 &quot;source1_v_C_filt_c&quot;
 &quot;source1_i_L2_c&quot;
 &quot;source1_v_C_cables_c&quot;
 &quot;cable1_i_L_c&quot;
 &quot;cable2_i_L_c&quot;
 &quot;load1_v_C_total_c&quot;
 &quot;load1_i_L_c&quot;
 &quot;load2_v_C_total_c&quot;</code></pre><p>The IDs created here are unique and can be used to access particular states. When creating the IDs, the sources are checked first in the order LCL, LC and then L. Then the cables are listed, which are also arranged in order. For the loads the order is RLC, LC, RL, L, RC, C and then R.</p><p>For the three-phase case, the state IDs are repeated and the respective phase is added.</p><p>These can then be accessed as follows:</p><pre><code class="language-julia hljs">state = 3
println(state_list[state+ns*0])
println(state_list[state+ns*1])
println(state_list[state+ns*2])</code></pre><pre><code class="nohighlight hljs">source1_i_L2_a
source1_i_L2_b
source1_i_L2_c</code></pre><p>Or:</p><pre><code class="language-julia hljs">state = &quot;source1_i_L1&quot;
idx_of_state = findall(x-&gt;occursin(state, x), state_list)
idx = idx_of_state</code></pre><pre><code class="nohighlight hljs">3-element Vector{Int64}:
  1
 10
 19</code></pre><pre><code class="language-julia hljs">state = &quot;source1_i_L1_a&quot;
idx_of_state = findall(x-&gt;occursin(state, x), state_list)
idx = idx_of_state</code></pre><pre><code class="nohighlight hljs">1-element Vector{Int64}:
 1</code></pre><p>The actions in the grid are also assigned unique IDs, here the sources are sorted in order. The IDs are output via the function <code>GetActionIds()</code>.</p><pre><code class="language-julia hljs">GetActionIds(S1_L2)</code></pre><pre><code class="nohighlight hljs">3-element Vector{String}:
 &quot;source1_u_a&quot;
 &quot;source1_u_b&quot;
 &quot;source1_u_c&quot;</code></pre><pre><code class="language-julia hljs"></code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../NodeConstructor_Theory/">« The Nodeconstructor - Theory</a><a class="docs-footer-nextpage" href="../Default_Parameters/">Default Parameters »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 17 April 2023 05:27">Monday 17 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
